<skill name="boot" v="3">
<desc>First-run orientation. Read this to get started with LLXML.</desc>

<instruction>
PREREQUISITES:
- Git must be installed and configured (git config user.name/email)

DO THIS NOW:

0. If you haven't read self.xml (in this kernel directory) yet, STOP and read it first.
   That file defines the format. You need it before continuing.

1. Check if META/ directory exists at the project root.

2. IF NO META/ EXISTS:
   Tell the user:
   "This kernel hasn't been booted yet. I can help you:
   - Set up the full development environment (for developing LLXML itself)
   - Create a harness spec for your own workflow
   Which do you want to tackle first? Or something else?"
   
   Wait for their response.
   
   FOR DEV SETUP: Read skills/project-structure.xml first, then follow the <dev_setup> section below.
   FOR HARNESS: Read skills/harness-building.xml and follow it.

3. IF META/ EXISTS:
   Tell the user:
   "Kernel is booted. Available skills:"
   Then LIST the filenames in skills/.
   Then ask: "What do you want to work on? (Or: set up a remote kernel)"
   
   When they pick something, read that skill and follow it.
   If they want remote setup, follow the <remote_setup> section below.
   If the skill doesn't exist, offer options:
   - "I can help you write that skill"
   - "Want to see the existing skills again?"
   - "Or we can do something else"

Do not summarize this skill. Do not explain what you're going to do. Just do it.
</instruction>

<dev_setup>
To boot the kernel into a self-developing project, you need to wrap it.

STEP 1: ASK WHERE
Ask the user: "Where do you want to set up the kernel? (default: ~/dev/kernel/)"
Let them change it if they want.

STEP 2: THE INCEPTION MOVE
1. Create the project directory
2. Create main/ subdirectory and initialize git:
   ```bash
   mkdir main && cd main && git init
   ```
3. Copy the kernel files into main/ (don't move — safer during setup)
4. Commit the kernel:
   ```bash
   git add -A && git commit -m "Initial kernel import"
   ```
5. Create stable/ worktree from main:
   ```bash
   git worktree add ../stable -b stable
   ```

STEP 3: CREATE STRUCTURE
Create these directories and files:

```
<project-root>/
├── ll.xml                 # manifest (use template below)
├── main/                  # git repo (working branch)
│   └── [kernel files]
├── stable/                # stable branch worktree (for distribution)
├── META/
│   ├── loader.xml         # core context (use template below)
│   ├── PROMPTS.md         # session prompts (use template below)
│   ├── tickets/
│   │   ├── todo/
│   │   ├── in-progress/
│   │   ├── review/
│   │   └── done/
│   ├── mail/
│   │   ├── inbox/
│   │   ├── read/
│   │   └── trash/
│   ├── logs/
│   ├── spec/              # architecture specs (<app>, <library>)
│   └── ctx/               # assembled context for AI sessions
│       ├── template.xml         # blank template
│       ├── cleanup-kickoff.xml  # boot cleanup session
│       └── harness-kickoff.xml  # harness creation session
```

STEP 4: SEED THE INBOX
Create two mail items in META/mail/inbox/:

`[DATE]-boot-cleanup.md`:
```markdown
# Boot Cleanup

The kernel was copied (not moved) during boot setup.

## Action
Delete the original kernel files/directory that was used as the source.
The kernel now lives in main/ — the original is no longer needed.

## Context
This is safe to do once you've verified the boot completed successfully.
```

`[DATE]-create-harness.md`:
```markdown
# Create Your Harness

Now that the kernel is booted, you need a harness — a context assembler that watches your files and outputs context for AI agents.

## Action
Read skills/harness-building.xml and create your harness spec.

## Questions to Consider
- What do you want to call it? (default: "harness", but you could name it something memorable)
- What stack will you build it in? (Rust, Node, Go, etc.)
- Do you want a UI or headless?

## Getting Started
Use ctx/harness-kickoff.xml to start a session focused on this.
```

STEP 5: CONFIRM
Tell the user: "Kernel is booted. You're ready to develop."
Note: "I've added two items to your inbox — a cleanup reminder and a prompt to create your harness."
Then list the available skills and ask what they want to work on.
</dev_setup>

<remote_setup>
To establish a relationship with a kernel on another machine.

STEP 1: ASK OPERATION
Ask the user: "Do you want to:
- Deploy: Push this kernel to a new host
- Connect: Write a skill for an existing remote kernel
- Both: Deploy first, then connect"

STEP 2: DEPLOY (if selected)
1. Ask for target host info:
   - Hostname or IP (or SSH config entry)
   - Target directory (default: ~/dev/kernel)
   - Is Claude Code available on remote? (for agent-assisted boot)

2. Explain the plan:
   "Here's what I'll do:
   - SSH to {host} and verify access
   - Check curl and unzip are available
   - Pull seed.zip from GitHub and unzip to {target}
   - [If agent available] Have remote agent complete boot
   - [If no agent] Create minimal META/ skeleton
   Want to change anything?"
   
   Wait for approval before proceeding.

3. Verify SSH and prerequisites:
   ```bash
   ssh {host} "echo ok && which curl && which unzip"
   ```
   If this fails, stop and help user fix it first.

4. Deploy kernel:
   ```bash
   ssh {host} "mkdir -p {target}/main && cd {target}/main && curl -L {seed_url} -o seed.zip && unzip seed.zip && rm seed.zip"
   ```
   Default seed URL: https://github.com/llxml/kernel/releases/download/seed-v9/seed-v9.zip
   User can provide a custom URL or transfer a zip manually.
   (This URL is updated each release — see release-workflow.xml)

5. Initialize git and create stable worktree:
   ```bash
   ssh {host} "cd {target}/main && git init && git add -A && git commit -m 'Initial kernel import'"
   ssh {host} "cd {target}/main && git worktree add ../stable -b stable"
   ```

6. Boot the remote kernel (create META/):

   **Path A — Agent available:**
   ```bash
   ssh {host} "source ~/.zshrc 2>/dev/null; cd {target} && echo 'The kernel files are in main/ with git and stable worktree ready. Read main/boot.xml and create only the META/ structure.' | claude --dangerously-skip-permissions"
   ```
   Remote agent completes full boot (META/, templates, inbox).

   **Path B — No agent:**
   ```bash
   ssh {host} "mkdir -p {target}/META/{tickets/{todo,in-progress,review,done},mail/{inbox,read,trash},logs,ctx,remotes,spec}"
   ```
   Minimal skeleton. Functional but no templates.

7. Verify remote kernel:
   If agent available, confirm it responds:
   ```bash
   ssh {host} "source ~/.zshrc 2>/dev/null; cd {target} && echo 'Read main/self.xml and confirm you see the LLXML kernel' | claude"
   ```

8. Proceed to Connect step.

STEP 3: CONNECT
1. Create META/remotes/ if it doesn't exist:
   ```bash
   mkdir -p META/remotes
   ```

2. Ask about the remote:
   - Hostname and connection method
   - OS and environment
   - What it can do (build, run, deploy)
   - Any constraints (battery, connectivity)

3. Create remote skill using template below.

4. Tell user: "Remote skill created at META/remotes/{name}.xml"

STEP 4: TWO-WAY SETUP (optional)
Ask: "Can {remote} SSH back to this machine?"

Verify it works (use -A for agent forwarding if needed):
```bash
ssh -A {host} "ssh {local} 'echo ok'"
```

If yes and user wants two-way:
1. Explain the plan:
   "I'll create a remote skill on {remote} so it knows how to reach back here,
   then have its agent send a hello mail to verify the loop works."
   Wait for approval.

2. If SSH key needed, offer to copy public key:
   ```bash
   ssh-copy-id {user}@{local}
   ```
   (run from remote, or help set up)

3. Create remote skill on the remote kernel so it knows how to reach back:
   ```bash
   ssh -A {host} "mkdir -p {kernel_path}/META/remotes"
   ```
   Then create META/remotes/{local}.xml with local hostname, user, kernel path.

4. Verify the loop with a hello message using nohup (runs detached):
   ```bash
   ssh -A {host} "nohup bash -c 'sleep 5; source ~/.zshrc 2>/dev/null; cd {kernel_path} && echo \"Read main/skills/mail-workflow.xml first for filename format. Then read META/remotes/{local}.xml and send a hello mail to the {local} kernel inbox at {local}:{local_kernel_path}/META/mail/inbox/\" | claude --dangerously-skip-permissions' > /tmp/hello.log 2>&1 &"
   ```

5. Watch local META/mail/inbox/ for the hello message.

STEP 5: CONFIRM
List existing remote skills in META/remotes/.
Ask: "Want to set up another remote, or work on something else?"
</remote_setup>

<templates>
<ll_xml>
```xml
<ll name="kernel" v="1">
<desc>The LLXML kernel - a self-describing format for human-LLM communication</desc>
</ll>
```
</ll_xml>

<loader_xml>
```xml
<loader revision="[TODAY'S DATE]">

<purpose>
Core context for LLXML meta-development. Boot creates this when setting up META/.
</purpose>

<what_is_llxml>
LLXML is a self-describing format with two primitives:
- `<self>` — describes itself
- `<skill>` — teaches processes

Everything else (document types, workflows, project structures) are skills built on these primitives. The kernel is domain-agnostic; software development is just the first application.

Read main/self.xml for the full spec.
</what_is_llxml>

<kernel_vs_meta>
**Kernel** (ships): self.txt, self.xml, boot.xml, skills/
**META** (emerges): loader.xml, tickets/, logs/, mail/, ctx/, spec/

The kernel is sufficient for regeneration. Given the kernel and an LLM, the entire meta-development environment can be recreated. Boot guides this process.
</kernel_vs_meta>

<origin>
The seed (self.txt):
```
The language of a language that can describe and improve itself.
Any implementation satisfying this principle is valid.
```

LLXML is one implementation. Others could exist (LLYAML, LLJSON, etc.).

License: CC0 (public domain)
</origin>

<current_focus>
Check META/tickets/in-progress/ for active work.
Check META/mail/inbox/ for items needing attention.
</current_focus>

</loader>
```
</loader_xml>

<prompts_md>
```markdown
# Prompts

Copy these to start sessions.

## Boot
Read boot.xml

## Continue Work
Read META/loader.xml and check META/tickets/in-progress/ for active work.

## Process Mail
Read META/loader.xml and skills/mail-workflow.xml, then process META/mail/inbox/.
```
</prompts_md>

<template_xml>
```xml
<context>
<preamble>
[DESCRIBE THE SESSION PURPOSE]
</preamble>

<task>
[INSERT TASK HERE]
</task>

<files_to_read>
- META/loader.xml
- [ADD RELEVANT FILES]
</files_to_read>
</context>
```
</template_xml>

<cleanup_kickoff_xml>
```xml
<context>
<preamble>
Clean up after boot — delete the original kernel source files.
</preamble>

<task>
1. Verify the boot completed successfully (check main/, stable/, META/ exist)
2. Delete the original kernel files/directory that was copied from
3. Mark the cleanup inbox item as done
</task>

<files_to_read>
- META/loader.xml
- META/mail/inbox/*-boot-cleanup.md
</files_to_read>
</context>
```
</cleanup_kickoff_xml>

<harness_kickoff_xml>
```xml
<context>
<preamble>
Kickoff session for creating your harness — a context assembler for LLXML projects.
</preamble>

<task>
1. Read the harness-building skill
2. Discuss what you want from your harness (name, stack, features)
3. Create the harness spec in META/spec/
</task>

<files_to_read>
- META/loader.xml
- main/skills/harness-building.xml
</files_to_read>
</context>
```
</harness_kickoff_xml>

<remote_skill_xml>
```xml
<skill name="remote-{name}" v="1">
<desc>How to interact with the {name} kernel</desc>

<addressing>
Host: {hostname}
SSH config: {ssh_entry or "direct connection"}
User: {username}
</addressing>

<environment>
OS: {os}
Shell: {shell}
Kernel location: {kernel_path}
</environment>

<capabilities>
- {capability_1}
- {capability_2}
</capabilities>

<workflows>
<deploy>
To deploy to {name}:
1. {step}
</deploy>

<dispatch>
To send work to {name} kernel:
1. Write mail item describing task
2. Transfer mail item to {host}:{kernel_path}/META/mail/inbox/
3. Remote kernel processes inbox and executes
</dispatch>
</workflows>

<constraints>
- {constraint_1}
</constraints>
</skill>
```
</remote_skill_xml>
</templates>
</skill>
