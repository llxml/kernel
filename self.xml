<self v="8">
<intro>
LLXML: "LLM XML" - A self-describing format for human-LLM communication.
Two primitives: `<self>` (describes itself) and `<skill>` (teaches processes).
Everything else you build using skills.
</intro>

<philosophy>
Optimized for human-LLM communication:
- Token efficiency: terse tags, minimal boilerplate
- LLM comprehension: structure models parse naturally
- Human readability: clean enough to write by hand
- Expressivity: flexible for any domain

Markdown flows inside XML. Tags are short. Structure serves communication, not schema validation.
</philosophy>

<primitives>
Two root types define the kernel:

- `<self>` — A thing describing itself. Use for specs, definitions, anything that needs to explain what it is.
- `<skill>` — A thing teaching a process. Use for workflows, procedures, techniques an agent can learn.

All files use `name` and `v` as attributes on the root tag, with `<desc>` as the first child:
```xml
<skill name="my-skill" v="1">
<desc>What it is or when to use it</desc>
...
</skill>
```

Everything else — document types, workflows, project structures — are skills you write.
</primitives>

<freeform>
XML tags are freeform. Invent as needed. The name should imply the meaning.

If a tag needs formal semantics, write a `<self>` doc for it. If it's just organizational structure, just use it.

Tags like `<context>`, `<backstage>`, `<preamble>`, `<template>` work because their names are self-explanatory. No definition required.

This is what makes the format extensible — two defined primitives, infinite freeform structure.
</freeform>

<versioning>
Root tags support an optional `v` attribute for version tracking:

```xml
<skill v="3">
<self v="8">
```

Rules:
- Whole numbers only, no decimals
- Increment when document is finalized, not during iteration
- Optional: missing `v` attribute implies version 0

Bump the version after editing is complete and the document is ready for use.
</versioning>

<type_notation>
Terse hybrid notation for data structures:

```
struct User {
    id: i64,
    name: str,
    email?: str,           # optional
    tags: str[],           # array
    metadata: str -> any,  # map
}

enum Status {
    Pending,
    Active,
    Suspended { reason: str, until: i64 },
}
```

Primitives: str, i32, i64, u32, u64, f32, f64, bool, any, u8[]

Avoid language-specific types. Keep it portable.
</type_notation>

<styling>
- Markdown inside XML flows naturally
- Terse tag names: `<stack>` not `<technology_stack>`
- Nest only when semantically meaningful
- Use attributes for identity (`name`, `v`), nested elements for content
- Invent domain-specific tags as needed
</styling>

<portability>
LLXML files should be portable across machines and users:

- No hardcoded absolute paths
- Use placeholders: `<dev-root>/`, `<project-root>/`
- Examples should use generic paths readers can adapt

This ensures specs and skills can be shared, vendored, and forked without modification.
</portability>

</self>
