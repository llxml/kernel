<skill name="project-structure" v="3">
<desc>Directory layout, worktrees, and library sharing</desc>

<overview>
Development is organized under dev roots containing projects grouped by type. Each project has a git repository (`main/`) with optional worktrees for parallel development. Libraries are shared via kernel worktrees.
</overview>

<dev_root>
A dev root is a directory containing project categories:

```
<dev-root>/
├── apps/                 # Full applications
├── libs/                 # Shared libraries
└── ...                   # Other project types
```

A harness scans configured roots for `ll.xml` manifests.
</dev_root>

<project_layout>
```
<project-root>/           # Operate from here
├── ll.xml                # Project manifest (signals "this is LLXML")
├── main/                 # THE git repository (has .git/)
├── kernel/               # Stable branch worktree (for vendoring, optional)
├── _feature-x/           # Feature worktrees (underscore prefix)
├── META/                 # Shared across worktrees, dev-time only
│   ├── spec/             # Architecture specs (<app>, <library>)
│   ├── skills/           # Project-specific skills
│   ├── tickets/          # Ticket workflow directories
│   ├── mail/             # Async message queue
│   └── logs/             # Development logs
└── ctx/                  # Assembled context output
```
</project_layout>

<worktrees>
Git worktrees allow multiple working directories from a single repository.

- `main/` is the **actual git repository** (contains `.git/` directory)
- Worktrees (`_feature-x/`) are lightweight checkouts that reference `main/.git`
- Worktrees are ephemeral - created for tickets, removed after merge
- `main/` is permanent - worktrees depend on it

<creating>
From project root:
```bash
cd main && git worktree add ../_{name} -b {name}
```

Creates branch `{name}` and directory `_{name}/` with that branch checked out.
</creating>

<removing>
After review and merge:
```bash
git worktree remove _{name}
```
</removing>
</worktrees>

<library_workflow>
<publishing>
Libraries have a `kernel` worktree for vendoring. "Publishing" = merging main to stable:
```bash
git -C kernel merge main
```
</publishing>

<consuming>
Projects vendor from the kernel worktree:
```bash
cd main
git submodule add file://<library-root>/kernel vendor/<name>
```

Then reference in your build config: `vendor/<name>/`
</consuming>
</library_workflow>

<key_concepts>
- **main/ is the repo** - Contains `.git/`, is the source of truth
- **Worktrees are ephemeral** - Created for features, removed after merge
- **META is shared** - Lives at project root, accessible from all worktrees
- **Operate from project root** - Not from inside main/ or worktrees
- **ll.xml is the manifest** - Signals a directory is an LLXML project
</key_concepts>

<naming_conventions>
- Project root: `<dev-root>/<type>/<name>/`
- Git repository: `<project-root>/main/`
- Kernel worktree: `<project-root>/kernel/`
- Feature worktrees: `<project-root>/_feature-name/`
- Vendor submodule: `main/vendor/<name>/`
</naming_conventions>
</skill>
