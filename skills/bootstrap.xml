<skill name="bootstrap" v="2">
<desc>Regenerating a full development environment from just the kernel</desc>

<philosophy>
The kernel is the portable, self-contained seed. Everything else emerges.

Given:
  - The kernel (zip, submodule, or clone)
  - An LLM
  - Minimal prompt guidance

You can regenerate:
  - The META structure (tickets, mail, reflection, logs)
  - A backstage.xml tailored to your project
  - The full meta-development workflow

The kernel ships. The environment emerges. This is by design—the kernel
must be sufficient for anyone to bootstrap their own development process.
</philosophy>

<overview>
Bootstrap creates a working LLXML project from the kernel. The kernel
contains the self-specification and skills; the project structure and
backstage context emerge from working with it.

Prerequisites:
- Git installed
- The LLXML kernel (or just the seed philosophy)
- A directory for your project
</overview>

<steps>
<step n="1" name="get-the-seed">
The seed lives at `seed.txt` in any LLXML distribution:

```
The language of a language that can describe and improve itself.
Any implementation satisfying this principle is valid.
```

This is the fixed point. Everything else grows from it.
</step>

<step n="2" name="create-project-structure">
```bash
mkdir -p myproject/{main,META/{spec,skills,tickets/{todo,in-progress,review,done},mail/{inbox,read,trash},reflection},ctx}
cd myproject/main && git init
```

Structure:
```
myproject/
├── ll.xml              # Manifest (create empty or with project name)
├── main/               # Git repository
├── META/               # Dev-time knowledge (not in git)
│   ├── spec/           # Architecture specs
│   ├── skills/         # Project-specific skills
│   ├── tickets/        # Task workflow
│   ├── mail/           # Async message queue
│   └── reflection/     # Concept development
└── ctx/                # Assembled context
```
</step>

<step n="3" name="create-manifest">
```bash
echo '<ll name="myproject" v="0"/>' > ll.xml
```

The manifest signals "this is an LLXML project" to tooling.
</step>

<step n="4" name="setup-backstage">
Create `META/backstage.xml` for project-level design context:

```xml
<backstage>
<desc>Design context for myproject</desc>

<goals>
- What this project aims to do
- Key constraints and decisions
</goals>

<status>
Current state of development.
</status>
</backstage>
```
</step>

<step n="5" name="vendor-llxml-optional">
If you want LLXML skills available:

```bash
cd main
git submodule add file:///path/to/llxml/kernel vendor/llxml
```

Then reference skills from `vendor/llxml/skills/`.

Note: LLXML uses `kernel` as its stable branch name (because it *is* the kernel). Your projects should use `stable`.
</step>
</steps>

<minimal_bootstrap>
Absolute minimum to start:

```bash
mkdir -p myproject/main && cd myproject
git -C main init
echo '<ll name="myproject"/>' > ll.xml
mkdir -p META/tickets/{todo,in-progress,review,done}
```

Add structure as needed.
</minimal_bootstrap>

<llm_bootstrap>
With an LLM, you can bootstrap interactively:

1. Give the LLM the kernel (vendor/llxml or a zip)
2. Prompt: "Read the LLXML kernel. Help me set up a new project called X."
3. The LLM reads self.xml and skills, then guides you through setup
4. Together you create META/backstage.xml tailored to your project
5. The development environment emerges from conversation

The kernel teaches the LLM how to help you. No external documentation needed.
</llm_bootstrap>

<kernel_sufficiency>
The kernel is designed to be self-sufficient for regeneration:

- self.xml defines the format (what tags mean)
- skills/ defines the processes (how to work)
- seed.txt anchors the philosophy (why it exists)

Everything else—backstage, tickets, mail, reflection—these are patterns
that emerge from applying the skills. They're not prescribed; they're
discovered through use.

Different teams may evolve different META structures. That's valid.
The kernel enables; it doesn't constrain.
</kernel_sufficiency>
</skill>
